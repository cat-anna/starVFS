/*
  * Generated by cppsrc.sh
  * On 2015-12-10 18:00:09,91
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef FileTable_H
#define FileTable_H

namespace StarVFS {

class FileTable final {
public:
 	FileTable(StarVFS *Owner);
 	~FileTable();

	void DumpStructure(std::ostream &out) const;
	void DumpFileTable(std::ostream &out) const;
	void DumpHashTable(std::ostream &out) const;

	File* AllocFile(const CString InternalFullPath);
	File* AllocFile(FileID Parent, FilePathHash PathHash, const CString FileName);

	struct FileStructureInfo {
		FileID m_Count;
		FilePathHash* m_PathHashTable;
		BaseFileInfo *m_FileTable;

		File* m_Parent;

		ContainerID m_OwnerContainer;

		bool IsValid() const { return m_OwnerContainer && m_Count && m_PathHashTable && m_FileTable && m_Parent; }
	};
	bool RegisterStructureTable(FileStructureInfo &info);
	
	template<class ... ARGS> FileID Lookup(ARGS... args) { return m_HashFileTable.Lookup(std::forward<ARGS>(args)...); }

	bool IsValid(FileID fid) const { return fid && fid < m_Allocated && m_FileTable[fid].m_Flags.Valid; }
	File* GetFile(FileID fid) const {
		if (!IsValid(fid)) return nullptr;
		return &m_FileTable[fid];
	}
	File* GetRawFile(FileID fid) const {
		if (!fid || fid >= m_Allocated) return nullptr;
		return &m_FileTable[fid];
	}
	bool IsFile(FileID fid) const {
		auto f = GetFile(fid);
		return f && !f->m_Flags.Directory;
	}
	bool IsDirectory(FileID fid) const {
		auto f = GetFile(fid);
		return f && f->m_Flags.Directory;
	}

	File* GetFileParent(const File *f) const { return GetFile(f->m_ParentFileID); }
	File* GetFileFirstChild(const File *f) const { return GetFile(f->m_FirstChild); }
	File* GetFileNextSibling(const File *f) const { return GetFile(f->m_NextSibling); }

	const CString GetFileName(FileID fid) const;
	String GetFileFullPath(FileID fid) const;
	bool GetFileData(FileID fid, ByteTable &data);
	FileFlags GetFileFlags(FileID fid) const;

	const StringTable* GetStringTable() const { return m_StringTable.get(); }
	const File* GetTable() const { return m_FileTable.get(); }
	FileID GetAllocatedFileCount() { return m_Allocated; }
	FileID GetRootID()const { return 1; }
	File* GetRoot() const { return m_FileTable.get() + GetRootID(); }

	Containers::FileTableInterface *AllocateInterface(const String& MountPoint);
	bool EnsureCapacity(FileID RequiredEmptySpace);
private:
	std::unique_ptr<StringTable> m_StringTable;
	std::vector<UniqueFileTableInterface> m_Interfaces;
	HashFileTable m_HashFileTable;
	std::unique_ptr<File[]> m_FileTable;
	FileID m_Capacity, m_Allocated;
	StarVFS *m_Owner;

	bool Realloc(FileID NewCapacity);

	File* AllocNewFile();
	File* AllocNewFile(FileID ParentID, FilePathHash PathHash, const CString FName);
	File* AllocNewFile(const CString fullpath);

};

} //namespace StarVFS 

#endif
