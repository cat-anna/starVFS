/*
  * Generated by cppsrc.sh
  * On 2016-01-01 18:40:09,38
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include "../nRDC.h"

namespace StarVFS {
namespace RDC {
namespace Version_1 {

struct Builder_v1::PrivateData : public Sections::SectionFileBuilderInterface {
//	std::vector<SectionDescriptor> m_Sections;

	virtual bool WriteBlockAtEnd(const char *data, Size size, DataBlock &blockdesc) override {
		return m_Owner->WriteBlockAtEnd(data, size, blockdesc);
	}

	virtual bool SubBlockWriteAtEnd(const char *data, Size size, DataBlock &blockdesc, DataBlock &base) override {
		return m_Owner->SubBlockWriteAtEnd(data, size, blockdesc, base);
	}

	PrivateData(Builder_v1 *Owner) : m_Owner(Owner) { }

	std::vector<std::unique_ptr<Sections::BaseSection>> m_Sections;

	template <class T, class ... ARGS>
	T* CreateSection(ARGS ...args) {
		static_assert(std::is_base_of<Sections::BaseSection, T>::value, "invalid base");
		SectionIndex idx = static_cast<SectionIndex>(m_Sections.size() + 1);
		auto ptr = std::make_unique<T>(this, idx, std::forward<ARGS>(args)...);
		auto rawptr = ptr.get();
		m_Sections.emplace_back(std::move(ptr));
		return rawptr;
	}
private:
	Builder_v1 *m_Owner;
};

Builder_v1::Builder_v1() {
	Reset();
}

Builder_v1::~Builder_v1() {
}

void Builder_v1::Reset() {
	m_Data = std::make_unique<PrivateData>(this);
	m_RawDataSectionCrated = false;
}

//-----------------------------------------------------------------------------

bool Builder_v1::WriteFileFooter() {
	FileFooter footer;

	std::vector<SectionDescriptor> RawSections;
	RawSections.resize(m_Data->m_Sections.size() + 1);

	for (size_t i = 0, j = m_Data->m_Sections.size(); i < j; ++i) {
		auto &it = m_Data->m_Sections[i];
		auto &out = RawSections[i + 1];

		out.SectionBlock = it->GetSectionDataBlock();
		out.Type = it->GetType();
	}

	if (!WriteBlockAtEnd((char*)&RawSections[0], sizeof(RawSections[0]) * RawSections.size(), footer.SectionTableBlock)) {
		//todo: log
		return false;
	}

	footer.SectionCount = static_cast<SectionIndex>(RawSections.size());
	return GetDevice()->WriteAtEnd((char*)&footer, sizeof(footer));
}

bool Builder_v1::WriteSections() {
	for (auto &it : m_Data->m_Sections) {
		if (!it->WriteSection()) {
			STARVFSErrorLog("WriteSection failed!");
			return false;
		}
	}
	return true;
}

//-----------------------------------------------------------------------------

bool Builder_v1::WriteBlockAtEnd(const char *data, Size size, DataBlock &blockdesc) {
	auto dev = GetDevice();
	if (!dev) {
		//todo: log
		return false;
	}

	blockdesc.FilePointer = static_cast<Size>(dev->GetSize());
	blockdesc.ContainerSize = size;

	if (!dev->WriteAtEnd(data, size))
		return false;

	return true;
}

bool Builder_v1::SubBlockWriteAtEnd(const char *data, Size size, DataBlock &blockdesc, DataBlock &base) {
	auto dev = GetDevice();
	if (!dev) {
		//todo: log
		return false;
	}

	blockdesc.FilePointer = static_cast<Size>(dev->GetSize());
	blockdesc.ContainerSize = size;

	if (!dev->WriteAtEnd(data, size))
		return false;

	return true;
}

//-----------------------------------------------------------------------------

Sections::StringTable* Builder_v1::CreateStringTableSection() {
	return m_Data->CreateSection<Sections::StringTable>();
}

Sections::MountEntrySection* Builder_v1::CreateMountEntrySection() {
	return m_Data->CreateSection<Sections::MountEntrySection>();
}

Sections::OffsetDataBlockTable* Builder_v1::CreateOffsetDataBlockTable() {
	return m_Data->CreateSection<Sections::OffsetDataBlockTable>();
}

Sections::RawDataSection* Builder_v1::CreateRawDataSection() {
	if (m_RawDataSectionCrated) {
		//todo: log
		return nullptr;
	}
	m_RawDataSectionCrated = true;
	return m_Data->CreateSection<Sections::RawDataSection>();
}

Sections::FileStructureTable* Builder_v1::CreateFileStructureTable() {
	return m_Data->CreateSection<Sections::FileStructureTable>();
}

Sections::HashTableSection* Builder_v1::CreateHashTable() {
	return m_Data->CreateSection<Sections::HashTableSection>();
}

} //namespace Version_1
} //namespace RDC 
} //namespace StarVFS 
