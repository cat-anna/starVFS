/*
  * Generated by cppsrc.sh
  * On 2016-01-03 22:43:01,77
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#include "../nRDC.h"

namespace StarVFS {
namespace RDC {
namespace Version_1 {


Reader_v1::Reader_v1() {
}

Reader_v1::~Reader_v1() {
}

//-----------------------------------------------------------------------------

bool Reader_v1::Open(const String& FileName) {
	if (m_FileDevice)
		return false;

	FileHeader header;
	FileFooter footer;

	{
		auto device = std::make_unique<BlockFileDevice>();
		if (!device->OpenForRead(FileName))
			return false;

		if (!TestHeaderIntegrity(device, &header))
			return false;

		if (header.Version.Major != 1)
			return false;

		if (!TestFooterIntegrity(device, &footer))
			return false;
		m_FileDevice.swap(device);
	}

	m_Sections.resize(footer.SectionCount);
	if (!ReadBlock((char*)&m_Sections[0], footer.SectionCount * sizeof(m_Sections[0]), footer.SectionTableBlock)) {
		m_Sections.clear();
		m_FileDevice.reset();
		return false;
	}

	return true;
}

//-----------------------------------------------------------------------------

bool Reader_v1::ReadBlock(void *data, Size size, const DataBlock &blockdesc) const {

	auto dev = GetDevice();
	if (!dev) {
		//todo: log
		return false;
	}

	if (!dev->ReadFromBegining(blockdesc.FilePointer, (char*)data, size))
		return false;

	return true;
}

bool Reader_v1::ReadBlock(CharTable &out, Size &out_size, const DataBlock &blockdesc) const {
	out.reset();
	out_size = 0;

	CharTable ct;
	out_size = blockdesc.GetRawSize();
	ct.reset(new char[out_size + 1]);
	ct[out_size] = 0;

	out.swap(ct);
	return true;
}

//-----------------------------------------------------------------------------

template<SectionType Type, class TableType>
bool Reader_v1::BaseReadTableBlock(SectionIndex Index, TableType &out) const {
	out.reset();

	if (m_Sections.size() <= (size_t)Index) {
		STARVFSErrorLog("Invalid section index! (index: %d, tabletype: %s)", Index, typeid(out).name());
		return false;
	}
	auto &section = m_Sections[Index];
	if (section.Type != Type) {
		STARVFSErrorLog("Invalid section type! want:%d got:%d (index: %d, tabletype: %s)", Type, section.Type, Index, typeid(out).name());
		return false;
	}

	out.New(section.SectionBlock.GetRawSize() / sizeof(TableType::item_t));
	if (!ReadBlock(out.get(), out.byte_size(), section.SectionBlock)) {
		STARVFSErrorLog("Failed to read block (index: %d, tabletype: %s)", Index, typeid(out).name());
		return false;
	}

	return true;
}

bool Reader_v1::LoadHashTable(SectionIndex Index, HashTable &out) const {
	return BaseReadTableBlock<SectionType::HashTable>(Index, out);
}

bool Reader_v1::LoadOffsetDataBlockTable(SectionIndex Index, OffsetDataBlockTable &out) const {
	return BaseReadTableBlock<SectionType::OffsetDataBlockTable>(Index, out);
}

bool Reader_v1::LoadFileStructureTable(SectionIndex Index, FileStructureTable &out) const {
	return BaseReadTableBlock<SectionType::FileStructureTable>(Index, out);
}

bool Reader_v1::LoadStringTable(SectionIndex Index, StringTable &out) const {
	return BaseReadTableBlock<SectionType::StringTable>(Index, out);
}

bool Reader_v1::FindMountEntries(std::vector<MountEntryInfo> &out) const {
	out.clear();
	for (size_t i = 0, j = m_Sections.size(); i < j; ++i) {
		auto &it = m_Sections[i];
		if (it.Type != SectionType::MountEntry)
			continue;

		out.emplace_back();
		auto &item = out.back();
		if (!ReadBlock(&item.m_MountEntry, sizeof(item.m_MountEntry), it.SectionBlock)) {
			out.pop_back();
			//todo: not ignore error?
			continue;
		}

		item.m_SectionIndex = static_cast<SectionIndex>(i);
	}

	return true;
}

//-----------------------------------------------------------------------------

bool Reader_v1::TestFooterIntegrity(UniqueBlockFileDevice &device, FileFooter *footer) {
	FileFooter localfooter;
	if (!footer)
		footer = &localfooter;

	if (!device->ReadFromEnd(sizeof(*footer), (char*)footer, sizeof(*footer)))
		return false;

	if (footer->Signature != Signature::Footer) {
		STARVFSDebugInfoLog("Invalid footer signature!");
		return false;
	}

	return true;
}

} //namespace Version_1 
} //namespace RDC 
} //namespace StarVFS 
