/*
  * Generated by cppsrc.sh
  * On 2015-12-10 17:53:58,21
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef StarVFS_H
#define StarVFS_H

namespace StarVFS {

class StarVFS {
public:
 	StarVFS(unsigned FSFlags = 0);
 	virtual ~StarVFS();

	VFSErrorCode OpenContainer(const String& ContainerFile, const String &MountPoint = "/", unsigned ContainerFlags = 0);

	/** Debug function. Prints all files in human-readable format. */
	void DumpStructure(std::ostream &out) const;
	void DumpFileTable(std::ostream &out) const;

	bool ForcePath(const String& path);

	FileID FindFile(const String& FileName);
	bool IsFileValid(FileID fid) const;
	bool IsFileDirectory(FileID fid) const;
	String GetFullFilePath(FileID fid) const;
	const CString GetFileName(FileID fid) const;
	FileSize GetFileSize(FileID fid) const;

	FileHandle OpenFile(const String& FileName, RWMode ReadMode = RWMode::R, OpenMode FileMode = OpenMode::OpenExisting);
	FileHandle OpenFile(FileID fid, RWMode ReadMode = RWMode::R);

	template<class T, class ...ARGS>
	bool LoadModule(ARGS ...args) {
		static_assert(std::is_base_of<Modules::iModule, T>::value , "Invalid module class!");
		m_Modules.push_back(std::make_unique<T>(this, std::forward<ARGS>(args)...));
		return true;
	}
	size_t GetModuleCount() const { return m_Modules.size(); }
	Modules::iModule* GetModule(size_t mid) {
		if (mid >= GetModuleCount()) 
			return nullptr;
		return m_Modules[mid].get();
	}

	FileTable* GetFileTable() { return m_FileTable.get(); }
	HandleTable* GetHandleTable() { return m_HandleTable.get(); }
protected:
//	virtual bool CanLoadContainer(iContainer *container);
//	virtual void OnContaierLoaded(iContainer *container);
private:
	unsigned m_Flags;
	std::unique_ptr<FileTable> m_FileTable;
	std::unique_ptr<HandleTable> m_HandleTable;
	std::vector<std::unique_ptr<Modules::iModule>> m_Modules;

	VFSErrorCode CreateContainer(Container& out, const String& ContainerFile, unsigned ContainerFlags);
};

} //namespace StarVFS 

#endif
