/*
* Generated by cppsrc.sh
* On 2016-01-08 22:38:03,59
* by Paweu
*/
/*--END OF HEADER BLOCK--*/

#include <sstream>
#include <cassert>

#include "RDCMetaModule.h"
#include <core/Container/VirtualFileContainer.h>
#include <core/Container/RDCContainer.h>

//-----------------------------------------------------------------------------

using namespace StarVFS::Containers;

struct RDCMetaModule::Impl {
	VirtualFileContainer *m_Container;
	std::vector<SharedVirtualFileInterface> m_MetaFiles;
	RDCContainer *m_RDC;
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

struct SectionsMetaFile : public BaseDynamicFileInterface {
	SectionsMetaFile(RDCContainer *RDC) : m_RDC(RDC) {
		assert(RDC);
	}
	virtual void GenerateContent(std::ostream &out) override {
		auto rdc = m_RDC->GetRDCReader();

		auto &sections = rdc->GetSections();

		out << "Section table meta file\n";
		out << "Container has " << sections.size() << " sections\n\n";

		for (auto &it : sections) {
			char buf[4096], buf128[128];

			using SectionType = StarVFS::RDC::SectionType;
			const char *stype = "Unknown";
			switch (it.Type) {
			case SectionType::EmptyEntry: stype = "Empty section"; break;
			case SectionType::MountEntry: stype = "Mount entry section"; break;
			case SectionType::RawData: stype = "Raw data section"; break;
			case SectionType::OffsetDataBlockTable: stype = "Offset datablock section"; break;
			case SectionType::StringTable: stype = "String table section"; break;
			case SectionType::FileStructureTable: stype = "File structure section"; break;
			case SectionType::HashTable: stype = "Hash section"; break;
			}
			sprintf(buf128, " (%d in container)", it.SectionBlock.ContainerSize);
			sprintf(buf,
					"Section %d\n"
					"Type: %s\n"
					"Location: 0x%x\n"
					"Size %d bytes%s\n",
					&it - &sections[0], stype,
					it.SectionBlock.FilePointer, it.SectionBlock.GetRawSize(),
					((it.SectionBlock.GetRawSize() == it.SectionBlock.ContainerSize) ? "" : buf128));
			out << buf << "\n";
		}
	}
private:
	RDCContainer *m_RDC;
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

RDCMetaModule::RDCMetaModule(StarVFS::StarVFS *svfs, RDCContainer *RDC) : StarVFS::Modules::iModule(svfs) {
	m_Impl = std::make_unique<Impl>();
	m_Impl->m_RDC = RDC;
}

RDCMetaModule::~RDCMetaModule() {
}

//-------------------------------------------------------------------------------------------------

bool RDCMetaModule::Enable() {
	if (m_Impl->m_Container)
		return true;

	auto ret = GetVFS()->CreateContainer<VirtualFileContainer>("/");
	if (!ret.second)
		return false;
	m_Impl->m_Container = dynamic_cast<VirtualFileContainer*>(ret.second);
	if (!m_Impl->m_Container)
		return false;

	{
		auto f = std::make_shared<SectionsMetaFile>(m_Impl->m_RDC);
		m_Impl->m_MetaFiles.emplace_back(f);
		m_Impl->m_Container->AddFile(f, "/$Sections");
	}
	return true;
}

bool RDCMetaModule::Disable() {
	if (m_Impl->m_Container)
		return true;

	m_Impl->m_MetaFiles.clear();

	//	m_MetaContainer = nullptr;
	return false;
}

//-----------------------------------------------------------------------------
