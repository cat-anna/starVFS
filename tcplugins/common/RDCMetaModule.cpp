/*
* Generated by cppsrc.sh
* On 2016-01-08 22:38:03,59
* by Paweu
*/
/*--END OF HEADER BLOCK--*/

#include <sstream>
#include <cassert>
#include <iomanip>

#include "RDCMetaModule.h"
#include <core/Container/VirtualFileContainer.h>
#include <core/Container/RDCContainer.h>

//-----------------------------------------------------------------------------

using namespace StarVFS::Containers;

struct RDCMetaModule::Impl {
	VirtualFileContainer *m_Container;
	std::vector<SharedVirtualFileInterface> m_MetaFiles;
	RDCContainer *m_RDC;
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

static char *SizeToString(char *buffer, float value) {
	int mag = 0;
	while (value > 1000.0f) {
		value /= 1024.0f;
		++mag;
	}
	static const char *MagTable[] = {
		"b", "KiB", "MiB", "GiB", "TiB", "?", "?",
	};
	sprintf(buffer, "%5.2f %s", value, MagTable[mag]);
	return buffer;
}

struct SectionsMetaFile : public BaseDynamicFileInterface {
	SectionsMetaFile(RDCContainer *RDC) : m_RDC(RDC) {
		assert(RDC);
	}
	virtual void GenerateContent(std::ostream &out) override {
		auto rdc = m_RDC->GetRDCReader();

		auto &sections = rdc->GetSections();

		out << "Section table meta file\n";
		out << "Container has " << sections.size() << " sections\n\n";

		for (auto &it : sections) {
			char buf128[128];

			using SectionType = StarVFS::RDC::SectionType;
			const char *stype = "Unknown";
			switch (it.Type) {
			case SectionType::EmptyEntry: stype = "Empty section"; break;
			case SectionType::MountEntry: stype = "Mount entry section"; break;
			case SectionType::RawData: stype = "Raw data section"; break;
			case SectionType::OffsetDataBlockTable: stype = "Offset datablock section"; break;
			case SectionType::StringTable: stype = "String table section"; break;
			case SectionType::FileStructureTable: stype = "File structure section"; break;
			case SectionType::HashTable: stype = "Hash section"; break;
			}
			sprintf(buf128, " (%d in container)", it.SectionBlock.ContainerSize);
			out << "Section " << &it - &sections[0] << "\n";
			out << "Type: " << (int)it.Type  << " (0x" << std::hex  << std::setw(2) << std::setfill('0') << (int)it.Type << ") (" << stype << ")\n";
			out << "Location: 0x" << std::hex << it.SectionBlock.FilePointer << std::dec << "\n";
			auto RawSize = it.SectionBlock.GetRawSize();
			out << "Size: " << RawSize << " bytes (" << SizeToString(buf128, (float)RawSize) << ")\n";
			if (RawSize != it.SectionBlock.ContainerSize) {
				out << "Container size: " << it.SectionBlock.ContainerSize << " bytes (" << SizeToString(buf128, (float)it.SectionBlock.ContainerSize) << ")\n";
			}
			out << "\n";
		}
	}
private:
	RDCContainer *m_RDC;
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

RDCMetaModule::RDCMetaModule(StarVFS::StarVFS *svfs, RDCContainer *RDC) : StarVFS::Modules::iModule(svfs) {
	m_Impl = std::make_unique<Impl>();
	m_Impl->m_RDC = RDC;
}

RDCMetaModule::~RDCMetaModule() {
}

//-------------------------------------------------------------------------------------------------

bool RDCMetaModule::Enable() {
	if (m_Impl->m_Container)
		return true;

	auto ret = GetVFS()->CreateContainer<VirtualFileContainer>("/");
	if (!ret.second)
		return false;
	m_Impl->m_Container = dynamic_cast<VirtualFileContainer*>(ret.second);
	if (!m_Impl->m_Container)
		return false;

	{
		auto f = std::make_shared<SectionsMetaFile>(m_Impl->m_RDC);
		m_Impl->m_MetaFiles.emplace_back(f);
		m_Impl->m_Container->AddFile(f, "/$Sections");
	}
	return true;
}

bool RDCMetaModule::Disable() {
	if (m_Impl->m_Container)
		return true;

	m_Impl->m_MetaFiles.clear();

	//	m_MetaContainer = nullptr;
	return false;
}

//-----------------------------------------------------------------------------
